import {  } from "./lib/std.js";
// console.log(new Array(123).fill(0).map((_, id) => id));
// Accumulated \`0..=100\` into ${0..=100.reduce((a,b) => a+b)} by reduce
// console.log(0..=123);
// console.log(10..123);
// console.log(0..);
// console.log(10.., "abc");
// console.log(`Accumulated \`0..=1000\` into ${0..=1000.reduce((a,b) => a+b)} by reduce`)


/* ----- for-of capture ----- */

// let acc = 0
// for (0..1000) |i| { acc += i }
// console.log(`Accumulated \`0..1000\` into ${acc} by capture`)
// for (["a",1,{},false], [1, 2], 0..) |v, v2, i| {
//     console.log(`Items #${i} is ${v} and ${v2}`);
// }

/* ----- operator overload ----- */

class ZigString {
  /**
   * This constructor example gets expanded into this:
   * #data
   * constructor(str="default"){this.#data=str;}
   * -----
   * for object you may use next syntax:
   * constructor({#data = str = "default"}) {},
   * it will get expanded like this:
   * #data
   * constructor({str}={str:"default"}){this.#data=str}
   * -----
   * if (in this case) #data property was manually added to the class body, it wont be autogenerated
   */
  constructor(#data = str = "default") { }


  // operators tell the compiler to keep track of certain operations done with this struct or class and replace these operations with assigned functions
  concatAssign |++=| (/** @type {ZigString} */ other) {
    this.#data += other.#data
  }

  // yes in this case doing `foo ++= bar ++= baz` is cheaper, but in reality you must use this function at a stupid scale to see any difference
  concat |++| (/** @type {ZigString} */ other) {
    return new ZigString(self.#data + other.#data)
  }
}

/* ----- native types ----- */
// std types, u8 made from new Uint8Array(1), i16 from new Int16Array, u64 or i64 from new [Uint/Int]64Array etc...
// supports floats too, f16 is unsupported everywhere but firefox
// this is just sugar for underlying library

// let a = 0_u16
// let b = 0_i32
// let c = 0_f64
// let d = 0_i8

// ----- struct-----
  // goes hand in hand with native types, and is just a sugar for underlying library
  // works similarly to C structs


  // struct Vector2 {
  //     x, y

  //     scale(num) {
  //         this.x *= num
  //         this.y *= num
  //     }

  //     add(other) {
  //         this.x += other.x
  //         this.y += other.y
  //     }
  // }

//   ----- end-----
