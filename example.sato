// console.log(new Array(123).fill(0).map((_, id) => id));
// Accumulated \`0..=100\` into ${0..=100.reduce((a,b) => a+b)} by reduce
// console.log(0..=123);
// console.log(10..123);
// console.log(0..);
// console.log(10.., "abc");
// console.log(`Accumulated \`0..=1000\` into ${0..=1000.reduce((a,b) => a+b)} by reduce`)


/* ----- for-of capture ----- */

// let acc = 0
// for (0..1000) |i| { acc += i }
// console.log(`Accumulated \`0..1000\` into ${acc} by capture`)
// for (["a",1,{},false], [1, 2], 0..) |v, v2, i| {
//     console.log(`Items #${i} is ${v} and ${v2}`);
// }

/* ----- operator overload ----- */

class Vector2 {
  x: Function<(), void> = 10;
  a
  /**
   * This constructor example gets expanded into this:
   * x;
   * y;
   *
   * constructor(x = 0, y = 0) {
   *   this.x = x;
   *   this.y = y;
   * }
   * -----
   * for object you may use next syntax:
   * constructor({x = x = 0, y = y = 0}) {},
   * it will get expanded like this:
   * x;
   * y;
   *
   * constructor({x, y} = {x: 0, y: 0}) {
   *   this.x = x;
   *   this.y = y;
   * }
   * -----
   * if (in this case) `x` and/or `y` property was manually added to the class body, it wont be autogenerated
   */
  constructor(x = x = 0, y = y = 0) {}


  // operators tell the compiler to keep track of certain operations done with this struct or class and replace these operations with assigned functions
  scale |*| (/** @type {number} */ num) {
    return new Vector2(x * num, y * num)
  }
  scaleThis |*=| (/** @type {number} */ num) {
    this.x *= num
    this.y *= num
  }

  add |+| (/** @type {Vector2} */ other) {
    return new Vector2(x + other.num, y + other.num)
  }
  addThis |+=| (/** @type {Vector2} */ other) {
    this.x += other.x
    this.y += other.y
  }

  sub |-| (/** @type {Vector2} */ other) {
    return new Vector2(x - other.x, y - other.y)
  }
  subThis |-=| (/** @type {Vector2} */ other) {
    this.x -= other.x
    this.y -= other.y
  }

  cmp |==| (/** @type {Vector2} */ other) {
    return this.x == other.x && this.y == other.y
  }
  cmp_exact |===| (/** @type {Vector2} */ other) {
    return this.x === other.x && this.y === other.y
  }

  normalize |^| () {
    this *= 1 / |this
  }

  dot |**| (/** @type {Vector2} */ other) {
    return this.x * other.x + this.y * other.y
  }

  len ||| () {
    return Math.sqrt(this ** this)
  }

  cross |><| (/** @type {Vector2} */ other) {
    throw new Error("Cross product only makes sence in 3D and 7D spaces")
  }
}

/* ----- native types ----- */
// std types, u8 made from new Uint8Array(1), i16 from new Int16Array, u64 or i64 from new [Uint/Int]64Array etc...
// supports floats too, f16 is unsupported everywhere but firefox
// this is just sugar for underlying library

// let a = 0_u16
// let b = 0_i32
// let c = 0_f64
// let d = 0_i8

// ----- struct-----
  // goes hand in hand with native types, and is just a sugar for underlying library
  // works similarly to C structs


  // struct Vector2 {
  //     x, y

  //     scale(num) {
  //         this.x *= num
  //         this.y *= num
  //     }

  //     add(other) {
  //         this.x += other.x
  //         this.y += other.y
  //     }
  // }

//   ----- end-----
