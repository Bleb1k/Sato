import { splitParameters } from "./lib.js" 

const foo = `class Foo {
  /**
   * This constructor example gets expanded into this:
   * #data
   * constructor(str="default"){this.#data=str;}
   * -----
   * for object you may use next syntax:
   * constructor({#data = str = "default"}) {},
   * it will get expanded like this:
   * #data
   * constructor({str}={str:"default"}){this.#data=str}
   * -----
   * if (in this case) #data property was manually added to the class body, it wont be autogenerated
   */
  constructor(#data = str = "default") {}


    // operators tell the compiler to keep track of certain operations done with this struct or class and replace these operations with assigned functions
  concatAssign |++=| (/** @type {ZigString} */other) {
    this.#data += other.#data
  }

// yes in this case doing \`foo ++= bar ++= baz\` is cheaper, but in reality you must use this function at a stupid scale to see any difference
  concat |++| (/** @type {ZigString} */other) {
    return new ZigString(self.#data + other.#data)
  }
}`

/** @link {https://regex101.com/r/5bqW4M/4} */
const classRegex = /(?<paren>[{}])|(?<className>(?<=(?:class)\s+)\w+)|(?<function>(?<fnPad>\n +)(?<fnGetSet>get|set)??\s*(?<fnName>#?\w+)\s*(?:\|(?<fnOp>[^\w\s|]+?)\|)?\s*\((?<fnParams>[^]*?)\)\s*(?<fnBody>{(?:(?:[^\n]*?\n *(?<=(?:\k<fnPad>)))*}|[^]*?}))\n)|(?<comment>\/\/.*$|\/\*[^]*?\*\/)|[{}]|(?<param>(?<paramPad>\n +)(?<paramName>#?\w+)(?:\s*:\s*(?<paramType>\w+))?(?:\s*=\s*(?<paramDefault>[^]*?)(?=\k<paramPad>[\w#/]))?)|(?<class>class)/mg

for (const match of foo.matchAll(classParser)) {
  console.log(match.index, match.groups, [match[0]])
}
